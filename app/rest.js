// Generated by CoffeeScript 1.6.2
var add_type, arg_map, async, die_on_error, fail_on_error, get_json, redis, set_json, _, _ref, _ref1;

_ = require('underscore');

async = require('async');

_ref = require('./persist'), set_json = _ref.set_json, get_json = _ref.get_json, redis = _ref.redis;

_ref1 = require('./util'), arg_map = _ref1.arg_map, fail_on_error = _ref1.fail_on_error, die_on_error = _ref1.die_on_error;

add_type = function(app, type, _arg) {
  var add, after_add, after_get, before_del, del, get, get_all, get_collection, load_child_list, save;

  after_add = _arg.after_add, before_del = _arg.before_del, after_get = _arg.after_get;
  if (after_add == null) {
    after_add = function(model, callback) {
      return callback();
    };
  }
  if (before_del == null) {
    before_del = function(model, callback) {
      return callback();
    };
  }
  if (after_get == null) {
    after_get = function(model, callback) {
      return callback(null, model);
    };
  }
  add = function(data, callback) {
    return redis.incr("atom:" + type + "_count", fail_on_error(callback, function(id) {
      data.id = id;
      return save(data, fail_on_error(callback, function() {
        return redis.rpush("atom:" + type + "s", id, fail_on_error(callback, function() {
          return after_add(data, fail_on_error(callback, function() {
            return callback(null, data);
          }));
        }));
      }));
    }));
  };
  save = function(data, callback) {
    return set_json("atom:" + type + "s:" + data.id, data, callback);
  };
  del = function(id, callback) {
    return get(id, fail_on_error(callback, function(model) {
      return before_del(model, fail_on_error(callback, function() {
        redis.del("atom:" + type + "s:" + id);
        return redis.lrem("atom:" + type + "s", 0, id, callback);
      }));
    }));
  };
  get = function(id, callback) {
    return get_json("atom:" + type + "s:" + id, fail_on_error(callback, function(data) {
      return after_get(data, callback);
    }));
  };
  get_collection = function(ids, callback) {
    if (ids == null) {
      ids = [];
    }
    return arg_map(async.map, 'array', 'iterator', 'callback', {
      array: ids,
      iterator: get,
      callback: callback
    });
  };
  get_all = function(callback) {
    return redis.lrange("atom:" + type + "s", 0, -1, fail_on_error(callback, function(model_ids) {
      return get_collection(model_ids, callback);
    }));
  };
  load_child_list = function(model, child, child_type, callback) {
    return redis.lrange("atom:" + type + "s:" + model.id + ":" + child, 0, -1, fail_on_error(callback, function(child_ids) {
      return child_type.get_collection(child_ids, fail_on_error(callback, function(children) {
        model[child] = children;
        return callback(null, model);
      }));
    }));
  };
  app.post("/" + type + "s", function(req, res) {
    return add(JSON.parse(req.body.json), die_on_error(res, function(model) {
      return res.send(200, JSON.stringify(model));
    }));
  });
  app.get("/" + type + "s.json", function(req, res) {
    return get_all(die_on_error(res, function(models) {
      return res.send(200, JSON.stringify(models));
    }));
  });
  app.get("/" + type + "s", function(req, res) {
    return get_all(die_on_error(res, function(models) {
      return res.send(200, JSON.stringify(models));
    }));
  });
  app["delete"]("/" + type + "/:id", function(req, res) {
    var id;

    id = req.params.id;
    return del(id, die_on_error(res, function(removed) {
      return res.send(200, removed);
    }));
  });
  app.post("/" + type + "/:id", function(req, res) {
    var model;

    model = JSON.parse(req.body.json);
    model.id = req.params.id;
    return save(model, die_on_error(res, function(saved) {
      return res.send(200, saved);
    }));
  });
  return {
    add: add,
    save: save,
    del: del,
    get: get,
    get_collection: get_collection,
    load_child_list: load_child_list,
    get_all: get_all
  };
};

module.exports = {
  add_type: add_type
};
